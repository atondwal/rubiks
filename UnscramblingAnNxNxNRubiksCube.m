(* ::Package:: *)

(* ::DemoTitle:: *)
(*Unscrambling an NxNxN Rubik's Cube*)


(* ::InitializationSection:: *)
(**)


(*Hardcoded polygons*)
polygons={
	{{x+.5,y-.5,z-.5},{x+.5,y+.5,z-.5},{x+.5,y+.5,z+.5},{x+.5,y-.5,z+.5},{x+.5,y-.5,z-.5}},
	{{x-.5,y-.5,z-.5},{x-.5,y+.5,z-.5},{x-.5,y+.5,z+.5},{x-.5,y-.5,z+.5},{x-.5,y-.5,z-.5}},
	{{x+.5,y+.5,z-.5},{x-.5,y+.5,z-.5},{x-.5,y+.5,z+.5},{x+.5,y+.5,z+.5},{x+.5,y+.5,z-.5}},
	{{x+.5,y-.5,z-.5},{x-.5,y-.5,z-.5},{x-.5,y-.5,z+.5},{x+.5,y-.5,z+.5},{x+.5,y-.5,z-.5}},
	{{x+.5,y-.5,z+.5},{x+.5,y+.5,z+.5},{x-.5,y+.5,z+.5},{x-.5,y-.5,z+.5},{x+.5,y-.5,z+.5}},
	{{x+.5,y-.5,z-.5},{x+.5,y+.5,z-.5},{x-.5,y+.5,z-.5},{x-.5,y-.5,z-.5},{x+.5,y-.5,z-.5}}
	};

(*Inital viewing vector*)
v={{5,5,5},{0,0,0}};

(* Dimension of the cube *)
dim=3;

(*A Cube is a function that maps points onto their colors. This is one example of a cube that we take to be our fiducial cube. *)
standardCube[{x_,y_,z_}]:=
	Which[
		Abs[x]>Abs[y]&&Abs[x]>Abs[z],	If[x<0,Green,Blue],
		Abs[y]>Abs[x]&&Abs[y]>Abs[z],	If[y<0,Yellow,White],
		True,				If[z<0,Orange,Red]
	]

(*These elements define rotations in the directions. They rotate a point in C^dim around the axis by Pi/2 in either direction *)
rot[axis_,sign_,p_]:=RotationMatrix[-sign Pi/2,IdentityMatrix[dim][[axis]]].p

(*These look a little messy beacuse we're using pure functions for pointfree expressions*)

(* Call this like cube[standardCube,rot[1,1,#]&] *)
cube[theCube_,rot_]:= theCube@rot@#&

(* The 3x3 RubikGroup is the group generated by permuations of t[{1,2,3},{-1,1},#]& with group multiplication a*b=a@b@#& *)
t[axis_,col_,theCube_]:=  If[col+.5>=#[[axis]]>=col-.5,theCube@rot[axis,If[col>0,1,-1],#],theCube@#]&

(*This function displays an N-cube*)
displayN[size_,theCube_]:=GraphicsGrid[
	{
		{Graphics3D[#,ViewVector->Dynamic[v]],Graphics3D[#,ViewVector->Dynamic[-v,(v=-#)&,TrackedSymbols:>v]]}&@
			(
				{Black,Glow[(theCube/.{Hold[{a_Integer,c_}]->(t[a,c,#]&)})@Mean@#],Polygon@#}&/@
					polygons/.{x->#,y->#2,z->#3}&@@@
						Flatten[Table[{i,j,k},{i,-(size/2-.5),size/2-.5},{j,-(size/2-.5),size/2-.5},{k,-(size/2-.5),size/2-.5}],2]
			),
			{
				TreeForm[
						theCube/.
							{Hold[{a_Integer,c_}]->{a,c}}/.
							(*label axes with letters instead of numbers*)
							{
								{1,a_}->{x,a},
								{2,a_}->{y,a},
								{3,a_}->{z,a}
							}/.
							(*On a standard cube, use standard move notation*)
							If[size==3&&dim==3,{
								{x,1}->"F",
								{x,0}->"S",
								{x,-1}->"B",
								{y,1}->"R",
								{y,0}->"M",
								{y,-1}->"L",
								{z,1}->"U",
								{z,-1}->"D",
								{z,0}->"E"
							},{}],
				EdgeRenderingFunction->({Red,Arrow[Reverse[#],.3]}&)],
			SpanFromLeft}
	}];


(* ::ManipulateSection:: *)
(**)


(* ::Input:: *)
Manipulate[
	DynamicModule[{listn},
		listn=	Reverse[displayN[size,#]&/@
				FoldList[#2@#&, standardCube, RandomChoice[Flatten[Table[Hold[{a,c}]@#&/.{a->axis,c->col},{axis,1,3},{col,-Ceiling[size/2-.5],Floor[size/2-.5]}]],length]]
			];
		Dynamic[
			Dynamic[
				listn[[step]],
			TrackedSymbols:>{step,listn}],
		TrackedSymbols:>{size,length}]
	],
	{{size,3},2,10,1}, {{length,3},0,10,1}, {step,1,length+1,1},
TrackedSymbols:>True,SaveDefinitions->True]


(* ::ManipulateCaptionSection:: *)
(**)


(* ::ManipulateCaption:: *)
(*Unshuffles an NxNxN Rubik's cube to the standard position. Move the length silder to change the number of moves, the size silder to change N, and the step silder to undo/redo transformations. Modifying the size or length rerandomizes the transformations. When using a standard 3x3x3 cube, it uses the standard Rubik's Cub move notation. Drag the two views of the cube to see it from a different angle*)


(* ::ThumbnailSection:: *)
(**)


(* ::SnapshotsSection:: *)
(**)


(* ::Output:: *)
(*Manipulate[displayN[theCube$_] := GraphicsGrid[{({Graphics3D[#1, ViewVector -> Dynamic[v]], Graphics3D[#1, ViewVector -> Dynamic[-v, (v = -#1) & , TrackedSymbols :> v]]} & )[*)
(*       Apply[({Black, Glow[(theCube$ /. {Hold[{a_Integer, c_}] -> (t[a, c, #1] & )})[Mean[#1]]], Polygon[#1]} & ) /@ polygons /. {x -> #1, y -> #2, z -> #3} & , *)
(*        Flatten[Table[{i, j, k}, {i, -(size/2 - 0.5), size/2 - 0.5}, {j, -(size/2 - 0.5), size/2 - 0.5}, {k, -(size/2 - 0.5), size/2 - 0.5}], 2], {1}]], *)
(*      {TreeForm[theCube$ /. {Hold[{a_Integer, c_}] -> {a, c}} /. {{1, a_} -> {x, a}, {2, a_} -> {y, a}, {3, a_} -> {z, a}} /. If[size == 3 && dim == 3, {{x, 1} -> "F", {x, 0} -> "S", {x, -1} -> "B", {y, 1} -> "R", {y, 0} -> "M", {y, -1} -> "L", *)
(*           {z, 1} -> "U", {z, -1} -> "D", {z, 0} -> "E"}, {}], EdgeRenderingFunction -> ({Red, Arrow[Reverse[#1], 0.3]} & )], SpanFromLeft}}]; *)
(*   DynamicModule[{listn}, listn = Reverse[displayN /@ FoldList[#2[#1] & , standardCube, RandomChoice[Flatten[Table[(Hold[{a, c}][#1] & ) /. {a -> axis, c -> col}, {axis, 1, 3}, {col, -Ceiling[size/2 - 0.5], Floor[size/2 - 0.5]}]], length]]]; *)
(*     Dynamic[Dynamic[listn[[step]], TrackedSymbols :> {step, listn}], TrackedSymbols :> {size, length}]], {{size, 5}, 2, 10, 1}, {{length, 3}, 0, 10, 1}, {step, 1, Dynamic[length + 1], 1}, TrackedSymbols :> True, ControllerLinking -> True, *)
(*  Initialization :> {v = {{5, 5, 5}, {0, 0, 0}}, t[axis_, col_, theCube_] := If[col + 0.5 >= #1[[axis]] >= col - 0.5, theCube[rot[axis, If[col > 0, 1, -1], #1]], theCube[#1]] & , *)
(*    rot[axis_, sign_, p_] := RotationMatrix[(-sign)*(Pi/2), IdentityMatrix[dim][[axis]]] . p, dim = 3, polygons = {{{0.5 + x, -0.5 + y, -0.5 + z}, {0.5 + x, 0.5 + y, -0.5 + z}, {0.5 + x, 0.5 + y, 0.5 + z}, {0.5 + x, -0.5 + y, 0.5 + z}, *)
(*       {0.5 + x, -0.5 + y, -0.5 + z}}, {{-0.5 + x, -0.5 + y, -0.5 + z}, {-0.5 + x, 0.5 + y, -0.5 + z}, {-0.5 + x, 0.5 + y, 0.5 + z}, {-0.5 + x, -0.5 + y, 0.5 + z}, {-0.5 + x, -0.5 + y, -0.5 + z}}, *)
(*      {{0.5 + x, 0.5 + y, -0.5 + z}, {-0.5 + x, 0.5 + y, -0.5 + z}, {-0.5 + x, 0.5 + y, 0.5 + z}, {0.5 + x, 0.5 + y, 0.5 + z}, {0.5 + x, 0.5 + y, -0.5 + z}}, {{0.5 + x, -0.5 + y, -0.5 + z}, {-0.5 + x, -0.5 + y, -0.5 + z}, {-0.5 + x, -0.5 + y, 0.5 + z}, *)
(*       {0.5 + x, -0.5 + y, 0.5 + z}, {0.5 + x, -0.5 + y, -0.5 + z}}, {{0.5 + x, -0.5 + y, 0.5 + z}, {0.5 + x, 0.5 + y, 0.5 + z}, {-0.5 + x, 0.5 + y, 0.5 + z}, {-0.5 + x, -0.5 + y, 0.5 + z}, {0.5 + x, -0.5 + y, 0.5 + z}}, *)
(*      {{0.5 + x, -0.5 + y, -0.5 + z}, {0.5 + x, 0.5 + y, -0.5 + z}, {-0.5 + x, 0.5 + y, -0.5 + z}, {-0.5 + x, -0.5 + y, -0.5 + z}, {0.5 + x, -0.5 + y, -0.5 + z}}}, *)
(*    standardCube[{x_, y_, z_}] := Which[Abs[x] > Abs[y] && Abs[x] > Abs[z], If[x < 0, Green, Blue], Abs[y] > Abs[x] && Abs[y] > Abs[z], If[y < 0, Yellow, White], True, If[z < 0, Orange, Red]]}]*)


(* ::Input:: *)
(*Manipulate[displayN[theCube$_] := GraphicsGrid[{({Graphics3D[#1, ViewVector -> Dynamic[v]], Graphics3D[#1, ViewVector -> Dynamic[-v, (v = -#1) & , TrackedSymbols :> v]]} & )[*)
(*       Apply[({Black, Glow[(theCube$ /. {Hold[{a_Integer, c_}] -> (t[a, c, #1] & )})[Mean[#1]]], Polygon[#1]} & ) /@ polygons /. {x -> #1, y -> #2, z -> #3} & , *)
(*        Flatten[Table[{i, j, k}, {i, -(size/2 - 0.5), size/2 - 0.5}, {j, -(size/2 - 0.5), size/2 - 0.5}, {k, -(size/2 - 0.5), size/2 - 0.5}], 2], {1}]], *)
(*      {TreeForm[theCube$ /. {Hold[{a_Integer, c_}] -> {a, c}} /. {{1, a_} -> {x, a}, {2, a_} -> {y, a}, {3, a_} -> {z, a}} /. If[size == 3 && dim == 3, {{x, 1} -> "F", {x, 0} -> "S", {x, -1} -> "B", {y, 1} -> "R", {y, 0} -> "M", {y, -1} -> "L", *)
(*           {z, 1} -> "U", {z, -1} -> "D", {z, 0} -> "E"}, {}], EdgeRenderingFunction -> ({Red, Arrow[Reverse[#1], 0.3]} & )], SpanFromLeft}}]; *)
(*   DynamicModule[{listn}, listn = Reverse[displayN /@ FoldList[#2[#1] & , standardCube, RandomChoice[Flatten[Table[(Hold[{a, c}][#1] & ) /. {a -> axis, c -> col}, {axis, 1, 3}, {col, -Ceiling[size/2 - 0.5], Floor[size/2 - 0.5]}]], length]]]; *)
(*     Dynamic[Dynamic[listn[[step]], TrackedSymbols :> {step, listn}], TrackedSymbols :> {size, length}]], {{size, 3}, 2, 10, 1}, {{length, 3}, 0, 10, 1}, {{step, 4}, 1, Dynamic[length + 1], 1}, TrackedSymbols :> True, ControllerLinking -> True, *)
(*  Initialization :> {v = {{5, 5, 5}, {0, 0, 0}}, t[axis_, col_, theCube_] := If[col + 0.5 >= #1[[axis]] >= col - 0.5, theCube[rot[axis, If[col > 0, 1, -1], #1]], theCube[#1]] & , *)
(*    rot[axis_, sign_, p_] := RotationMatrix[(-sign)*(Pi/2), IdentityMatrix[dim][[axis]]] . p, dim = 3, polygons = {{{0.5 + x, -0.5 + y, -0.5 + z}, {0.5 + x, 0.5 + y, -0.5 + z}, {0.5 + x, 0.5 + y, 0.5 + z}, {0.5 + x, -0.5 + y, 0.5 + z}, *)
(*       {0.5 + x, -0.5 + y, -0.5 + z}}, {{-0.5 + x, -0.5 + y, -0.5 + z}, {-0.5 + x, 0.5 + y, -0.5 + z}, {-0.5 + x, 0.5 + y, 0.5 + z}, {-0.5 + x, -0.5 + y, 0.5 + z}, {-0.5 + x, -0.5 + y, -0.5 + z}}, *)
(*      {{0.5 + x, 0.5 + y, -0.5 + z}, {-0.5 + x, 0.5 + y, -0.5 + z}, {-0.5 + x, 0.5 + y, 0.5 + z}, {0.5 + x, 0.5 + y, 0.5 + z}, {0.5 + x, 0.5 + y, -0.5 + z}}, {{0.5 + x, -0.5 + y, -0.5 + z}, {-0.5 + x, -0.5 + y, -0.5 + z}, {-0.5 + x, -0.5 + y, 0.5 + z}, *)
(*       {0.5 + x, -0.5 + y, 0.5 + z}, {0.5 + x, -0.5 + y, -0.5 + z}}, {{0.5 + x, -0.5 + y, 0.5 + z}, {0.5 + x, 0.5 + y, 0.5 + z}, {-0.5 + x, 0.5 + y, 0.5 + z}, {-0.5 + x, -0.5 + y, 0.5 + z}, {0.5 + x, -0.5 + y, 0.5 + z}}, *)
(*      {{0.5 + x, -0.5 + y, -0.5 + z}, {0.5 + x, 0.5 + y, -0.5 + z}, {-0.5 + x, 0.5 + y, -0.5 + z}, {-0.5 + x, -0.5 + y, -0.5 + z}, {0.5 + x, -0.5 + y, -0.5 + z}}}, *)
(*    standardCube[{x_, y_, z_}] := Which[Abs[x] > Abs[y] && Abs[x] > Abs[z], If[x < 0, Green, Blue], Abs[y] > Abs[x] && Abs[y] > Abs[z], If[y < 0, Yellow, White], True, If[z < 0, Orange, Red]]}]*)


(* ::DetailsSection:: *)
(**)


(* ::DetailNotes:: *)
(*Cube positions are represented by transformations from the Rubik's Group applied to the standard cube. A cube position is a function that tells you the color of a point, given the point. The transformations are shown as pairs of (axis of rotation, direction of rotation). The standard cube notation used for the 3x3x3 cube refers to which of the six faces receives a counterclockwise turn: back, front, left, right, down, up, and the middle pieces: equator, middle, standing.*)


(* ::ControlSuggestionsSection:: *)
(**)


(* ::ControlSuggestions:: *)
(*Checkbox[False]  Resize Images*)


(* ::ControlSuggestions:: *)
(*Checkbox[True]  Rotate and Zoom in 3D*)


(* ::ControlSuggestions:: *)
(*Checkbox[False]  Drag Locators*)


(* ::ControlSuggestions:: *)
(*Checkbox[False]  Create and Delete Locators*)


(* ::ControlSuggestions:: *)
(*Checkbox[False]  Slider Zoom*)


(* ::ControlSuggestions:: *)
(*Checkbox[False]  Gamepad Controls*)


(* ::ControlSuggestions:: *)
(*Checkbox[False]  Automatic Animation*)


(* ::ControlSuggestions:: *)
(*Checkbox[False]  Bookmark Animation*)


(* ::SearchTermsSection:: *)
(**)


(* ::SearchTerms:: *)
(*Rubik's cube*)


(* ::SearchTerms:: *)
(*Rubik*)


(* ::SearchTerms:: *)
(*cube*)


(* ::SearchTerms:: *)
(*unscramble*)


(* ::SearchTerms:: *)
(*3D*)


(* ::SearchTerms:: *)
(*higher-order functions*)


(* ::RelatedLinksSection:: *)
(**)


(* ::RelatedLinks:: *)
(*Wolfram Demonstrations Project: Rubik's Cube*)


(* ::RelatedLinks:: *)
(*Rubik's Cube -- from Wolfram MathWorld*)


(* ::RelatedLinks:: *)
(*Rubik's Group -- from Wolfram MathWorld*)


(* ::AuthorSection:: *)
(**)


(* ::Author:: *)
(*Contributed by: Anish Tondwalkar*)
